# Compiler

Простой компилятор, разработанный в рамках курса "Формальные грамматики и методы трансляции".

## Setup

Для сборки данного компилятора требуется [Go версии 1.18 или более](https://go.dev/dl/) (beta 1 подходит).

После установки Go 1.18 выполните в терминале:

```shell
go run cmd/compiler/main.go
```

## Architecture

### Взаимодействие модулей

Планируется организовать взаимодействие различных модулей компилятора посредством передачи сообщений через каналы Go между горутинами. Каждый модуль запускается в отдельной горутине и работает параллельно с другими модулями, при этом он получает от предыдущего модуля данные по каналу, переданному ему в качестве параметра, а результаты своей работы передает в другой канал, который может использоваться другим модулем компилятора. Таким образом, работа компилятора организована по принципу конвейера.

Каждый модуль работает в отдельной горутине, и работа компилятора завершается, когда заканчивают свою работу все горутины (типично это должен быть последний модуль компилятора, осуществляющий вывод ошибок или результатов компиляции в зависимости от ее успеха).

На данный момент предлагается такой набор модулей:

[Reader (модуль ввода)](#reader) => 
[Scanner (сканер, лексический анализатор)](#scanner) => 
[Syntax analyzer (синтаксический анализатор)](#syntax-analyzer) => 
[Semantic analyzer (семантический анализатор)](#semantic-analyzer) => 
[Code generator (генератор кода)](#code-generator).

### Обработка ошибок

Любой из модулей может прервать работу конвейера при возникновении критической ошибки. В остальных случаях модуль передает ошибку дальше для обработки следующим модулем. Это возможно благодаря тому, что по каналам передаются не обязательно только результаты работы в случае успеха, а [дизъюнктивное объединение](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF-%D1%81%D1%83%D0%BC%D0%BC%D0%B0) результата успеха и ошибки.

Требуется спроектировать вывод ошибок компиляции пользователю и механизм прерывания компиляции. Это планируется сделать после реализации лексического анализатора (т. к. тогда будет понятнее, какие ошибки и где возникают, а также будет возможность протестировать выбранный подход уже на практике).

### Reader

[Reader](internal/reader/reader.go) читает файл построчно и каждую строку разбивает на части - литералы ([Literal](internal/data/literal/literal.go)). При этом все знаки препинания и даже переход на новую строку также сохраняются как отдельные части для последующего анализа в следующих модулях.

Reader указывает для каждого литерала строку, начальный и конечный столбец (начиная индексирование с 0) для того, чтобы в последующих модулях можно было указать на возникшую ошибку на основе этих данных в литерале.

Reader использует регулярные выражения для нахождения [несловообразующих символов](https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/character-classes-in-regular-expressions). Это позволяет разбить прочитанную строку по ним и передать по частям следующим модулям.

### Scanner

### Syntax analyzer

### Semantic analyzer

### Code generator

## Testing
